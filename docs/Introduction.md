🧙🏻‍♀️ Ada is a **programming language**.

<img 
src="https://www.thesun.co.uk/wp-content/uploads/2016/10/NINTCHDBPICT000440322376.jpg?strip=all&w=763" 
alt="NN" 
 width="188" 
height="253" 
align="right">

👩🏻‍💻 Ada is named after **Augusta Ada Byron** (often now known as _Ada Lovelace_), the **first programmer in History**, and daughter of the poet Lord Byron. As such, is not an acronym, and only the **first letter is capitalized**. 


👩🏻‍✈️ Ada was designed by and for the Military, and you can tell. It was assumed **little computer science-specific knowledge**. Abstractions as “objects” and “classes” are rejected by more broad or intuitive concepts, as “variables” and “types”, allowing to non-IT engineers and techs to grasp it’s functionalities fast, and intuitively understand a piece of code they may have never looked at before and be able to modify it and work on it even under situations of high stress. The main question an Ada coder should be asking is: Will a tank operator, pilot, or marine, understand what is happening here by a quick glance? Also in a combat situation?

# 🌬 Ada is:

 * Reliable 
   * Built-in exception handling.
   * Most errors are detected at compile-time and of those remaining many are detected by runtime constraints. 
   * Run-time checking

 * Scalable
   * Designed for the development of very large software systems

 * Statically typed
 * Strongly typed

 * **Wide-spectrum** level <sub>low and abstract levels</sub>
   * Comprehensive as a high-level language
   * Direct low-level control.
   * Abstractable through the package and private type

 * Multi-paradigm
   * Structured.
   * Procedural
   * Imperative.
   * Object-oriented.
   * Modular.
   * Contracts.
   * Functional
   * _Agile_
      
 * Modern
   * The Compiler and tools keep up with the latest technologies.
   
 * Extended from Pascal and many other languages. 
     * ALGOL-like

 * Stable
   * Standardized
   * Portable

* Particularly strong in areas such as 
  * _**The very large**_.
     * The development of very large programs by multiple, loosely connected teams.
     * Features to help manage a large number of program components, and to help ensure those components are used consistently.

   * **`Real-time applications`**

   * `Low-level hardware access`

   * **Critical** programs.
     * High Integrity.
     * Safety-critical software
     * Correctness, robustness, security, and reliability are priorities.
     * Simplifies maintenance.
     * Has an emphasis on program **readability** over ease of writing. 
     * The language has features designed to make programming safer and less error prone. 
       * Some of these features involve extra run-time checking and thus entail a performance penalty. However, Ada’s design is such that the performance penalty is minimal.
         * This minimal checking runs better than in other languages, and is optimized by the compiler.
         * It is better than the alternative: A failure that keeps the program running in an unexpected state.

   * Good choice for open source development.
   * Long-lived programs that spend most of their time in the _maintenance phase_ of the _software life cycle_. 

   * Promotes the readability of programs. 
     * Case Insensitive
       * `True` is interpreted just as `TRUE` or `tRUe`. 
       * Meaning is semantically asigned, not syntactically. 
         * That's what semantics **is**
     * You may find Ada code to be rather verbose and tedious to write. However, that extra work pays off later by making the code clearer and easier to read when bugs must be fixed or enhancements written.
   
    * The development of embedded systems
      * Low-level hardware control
      * Multiple concurrent tasks
      * Real-time requirements are common.
      * Still retaining as much safety as feasible.

* Provides ample support for Real-time multiprocessor systems. 
  * Time predictability
  * Inter-task communication 
    * By Protected objects
  * Protected entries.
  * Support for explicit concurrency and parallel processing.
    * Tasks
    * Synchronous message passing
    * Protected objects
    * Non-determinism.
 


